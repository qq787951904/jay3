--线程创建
1.
继承Thread类
2.

       2. 实现Runnable接口
        new Thread(new RunnableTask()).start()

       3. 实现Callable接口（有返回值）
        FutureTask<String> futureTask = new FutureTask<>(new CallerTask());
        new Thread(futureTask).start();
        try {
            ／／等待任务执行完毕，并返回结果
            String result = futureTask.get ();
        }catch (ExecutionExcept on e) {}

-- 线程启动
调用 start 方法后线程并没有马上执行而 处于就绪状态， 这个就绪状态是指
线程已经获取了除 CPU 资源外的其 资源，等待获取 CPU 资源后才会真正处于运行状态。

--线程通知和等待

    --wait()函数
    
    调用条件： wait()方法的线程事先获取该共享对象的监视器锁，否则抛出IllegalMonitorStateException

    一个线程调用  共享变量.wait()， 线程阻塞。
    阻塞返回条件：1）其他线程调用共享变量notify()或notifyAll(); 2) 其他变量调用该线程的interrupt, 该线程抛出InterruptException返回
    
   虚假唤醒： 一个线程可以从挂起状态变为可以运行状态（ 就是被唤醒），
                     即使该线程没有被其他线程调用 notify()、 notifyAll()方法进行通知，或者被中断，或者等待超时。
    避免虚假唤醒：不停测试该线程被唤醒的条件是否满足，不满足则继续等待，也就是说在一个循环中调用 wait()方法进行防范。
    synchronized(obj){
        while(条件不满足){
            obj.wait()
        }
    }

        --一个生产者消费者模式例子
        //生产线程
        synchronized(queue){
            while(queue.size() == MAX_SIZE){
                try{
                    ／／挂起 前线程， 释放通过同步块获取的queue 的锁，，上消费者线程可以获取该锁，然后
                    获取队列里面的元素
                    queue.wait()
                }catch(Exception ex){}
            }
            queue.add(element);
            queue.notifyAll();
         }
        
        //消费者线程
        synchronized(queue){
            while(queue.size == 0){
                try{
                    ／／ 挂起当前线程，并释放通过同步块获取的queue 上的锁， 上生产者线程可以获取该锁，将生
                    产元素放入队列
                    queue.wait()
                }catch(Exception ex){}
            }
            queue.take();
            queue.notifyAll();
        }

            --注意：当前线程调用共享变量的 wait （） 方法后只会释放当前共享变量上
                的锁，如果当前线程还持有其他共享变量的锁，则这些锁是不会被释放

    --wait(long timeout)
        如果一个线程调用共享对象的该方法挂起后，没有在指定的 timeout ms 时间内被其他线程调用该共享变量的
        notify()或者 notifyAll()方法唤醒，那么该函数还是会因为超时而返回。


    --notify()
        一个线程调用共享对象的 notify （）方法后，会唤醒一个在该共享变量上调用 wait 系列 方法后被挂起的线程。 
        一个共享变量上可能会有多个线程在等待，具体唤醒哪个等待的线 程是随机的。

    --notifyAll()
        唤醒所有在该共享变量上由于调用 wait 系列方法而被挂起的线程。

--join()等待线程执行终止
    join是方法 Thread 类直接提供的 ,join是无参且返回值为 void 的方法
    --在main方法中启动两个线程并调用他们的join()方法
    ／／启动子线程
     threadOne .start() ;
     threadTwo .start() ;

     threadOne . join () ; 
     threadTwo . join () ;
    主线程首先会在调用 thread One.join（） 方法后被阻塞，等待 thread One 执行完 后返回
    threadOne 执行完毕后 threadOne.join （） 就会返回,然后主线程调用 threadTwo.join（） 方法后
    再次被阻塞 等待 threadTwo 执行完毕后返 。


  --线程睡眠sleep(timeout)方法  
        Thread 中有一个静态的 sleep 方法，当一个执行中的线程调用了 Thread 得sleep 方法后，调用线程会暂时让出指定时间的执行权，也就是在这期间不参与CPU 的调度，但 是该线程所拥有的监视器资源，比如锁还是持有不让出的。指定的睡眠时间到了后该函数会正常返回，线程就处于就绪状态，然后参与 CPU 的调度。

--让出CPU执行权yield方法
       当一 线程调用 yield 方法时， 当前线程会让出CPU 使用权，然后处于就绪状态，线程调度器会从线程就绪队列里面获取一个线程优先级最高的线程，当然也有可能会调度到 刚            刚让出 CPU 的那个线程来获取 CPU 执行权。调用yield方法时，线程只是让出自己剩余的时间片，并没有被阻塞挂起，而是处于就绪状态，

--线程中断
Java 中的线程中断是 种线程间的协作模式，通过设置线程的中断标志并不能直接终止该线程的执行 而是被中断的线程根据中断状态自行处理。

void interrupt()中断线程
例如，当线程A运行时，线程B可以调用线程int rrupt（）方法来设置线程的中断标志为 true 并立即返回。
设置标志仅仅是设置标志, 线程A实际并没有被中断， 它会继续往下执行。
如果线程A因为调用了wait 系列函数、 join 方法或者 sleep 方法而被阻塞挂起，这 候若线程B调用线程A的interrupt()方法
线程 A会在调用这些方法的地方抛 出InterruptedException而返回。


boolean isInterrupted()
检测当前线程是否被中断，如果是返回 true


boolean interrupt()
检测当前线程是否被中断，如果是返回 true，否则返回fal se 。
与 lnterrupted 不同的是，该方法如果发现当前线程被中断， 会清除中断标志.
并且该方法是 static 方法 通过 Thread 类直接调用。


--ThreadLocal
ThreadLocal是JDK 包提供的，它提供了线程本地变量，也就是如果你创建了一个
ThreadLocal变量，那么访问这个变量 的每个线程都会有这个变量的一个本地副本。
当多个线程操作这个变量时，实际操作的是自己本地内 存里面的变量，从而避免了线程安全问题。


--内存可见性
    一个线程对共享变量值的修改,能够及时地被其他线程看到。

-- 共享变量
    如果一个变量在多个线程的工作内存中都存在副本,那么这个变量就是这几个线程的共享变量
		--Java内存模型对共享内存的规定
    *所有的变量都存储在主内存中
    *每个线程都有自己的独立的工作内存,里面保存该线程使用到的变量副本(主内存中改变量的一份拷贝),每个线程只能操作自己的独立内存,无法操作主内存
    *线程对共享变量的所有操作都必须在自己的工作内存,不能直接从主内存中读写.
     *不同线程之间无法直接访问其他线程工作内存中的变量,线程间的变量值的传递需要通过主内存来完成.


    要实现共享变量的可见性,即线程1对共享变量的修改要想被线程2及时看到,必须要经过如下2个步骤:
		1.把工作内存1中更新过的共享变量刷新到主内存中
    2.将主内存中最新的共享变量的值更新到工作内存2中

    Java语言层面支持的可见性的实现方式 : synchronize 和 volatile , final

--原子性操作
所谓原子性操作，是指执行一系列操作时，这些操作要么全部执行，要么全部不执行， 不存在只执行其中 部分的情况。
如在number++操作中，一般都先读取当前值，然后＋1，再写入更新。这个过程是读-改-写的过程，如果不能保证这个过程是原子性的，那么就会出现线程安全问题。
    --如何保证多个操作的原子性？
        使用synchronized关键字，使用非阻塞CAS算法实现的原子性操作类AtomicXXX类

--synchronize 可以保证变量可见性和一段代码的原子性
    线程执行synchronize互斥(同步)代码的过程:
            1.获得互斥锁
            2.清空工作内存
            3.从主内存中拷贝变量的最新副本到工作内存
            4.执行代码
            5.将更改后的共享变量的值刷新到主内存
            6.释放互斥锁
   JMM关于synchronized的两条可见性规定:
            *线程解锁前,必须把共享变量的最新值刷新到主内存中
            *线程加锁时,将清空工作内存中共享变量的值,从而使用共享变量时需要从主内存中重新读取最新的值

        导致共享变量在线程间不可见的原因,以及synchronized对应的解决方案:

            1.线程的交叉执行-->synchronize相当于加了一把锁,锁内部的代码只能由一个线程来执行,保证了锁内部代码的原子性
            2.重排序结合线程交叉执行 -->因为线程不会交叉执行,重排序只是在一个线程内重排序,结合"as-if-serial"原理,
            不会对执行结果产生影响.  "as-if-serial"原理 : 无论如何重排序,    程序执行的结果应该与代码顺序执行的结果一致.
            3.共享变量更新后的值没有在工作内存与主内存间及时更新-->根据synchronize的两条可见性规范,保证共享变量的可见性.

--volatile 可以保证可见性,不能保证原子性
     原理: 通过加入内存屏障和禁止重排序优化来实入一条store屏障指令,将工作内存刷新到主内存中.
     对volatile变量执行读操作时,会在读操作前加入一条load屏障指令,读取主内存中的最新值.这样任何时刻,不同的线程总能看到volatile变量的最新值.

有volatile变量修饰的共享变量进行写操作的时候
lock前缀指令其实就相当于一个内存屏障。内存屏障是一组CPU处理指令，用来实现对内存操作的顺序限制。volatile的底层就是通过内存屏障来实现的。

       需要注意的是,volatile不能保证一段代码的原子性.
   针对volatile无法保证原子性,有三种解决方案:

          *使用synchronize关键字 (常用)
                    synchronize(this){
                        number ++;
                    }

       *使用ReentrantLock
                    private Lock lock = new ReentrantLock();
                    lock.lock();
                    try{
                        number ++;
                    }finally{

                        //用try...final...保证即使出现异常,锁也会释放.
                        lock.unlock();
                    }

        *使用Atomicinterger

       要在多线程中安全使用volatile变量,需同时满足:

       *对变量的写入操作不依赖其当前值:     不满足:number++,count=count*5   满足:boolean变量,记录温度变化的变量等
       *该变量没有包含在具有其他变量的不变式中:    不满足: 不变式 low < up

-- CAS 操作
    使用锁的缺点：当一个线程没有获取到锁时会被阻塞挂起 ，这会导致线程上下文的切换和重新调度开销。
    非阻塞的方法：volatile关键字、CAS
    CAS即Comp re and Swap ，其是 JDK 提供的非阻塞原子性操作，它通过硬件保证了 比较-更新操作的原子性。
    JDK 里面的 Unsafe 类提供了一系列的 compareAndSwap ＊方法。


--UnSafe类

--乐观锁与悲观锁
    悲观锁指对数据被外界修改持保守态度，认为数据很容易就会被其他线程修改，所以 在数据被处理前先对数据进行加锁，并在整个数据处理过程中，使数据处于锁定状态。
悲观锁的实现往往依靠数据库提供的锁机制，即在数据库中 ，在对数据记录操作前给记录加排它锁。
如果获取锁失败， 则说明数据正在被其他线程修改，当前线程则阻塞。
如果获取锁成功，则对记录进行操作 ，然后提交事务后释放排它锁。
如：数据库行锁，表锁等，读锁，写锁，Java中synchronized和ReentrantLock等独占锁


乐观锁
总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号机制和CAS算法实现。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库提供的类似于write_condition机制，其实都是提供的乐观锁。在Java中java.util.concurrent.atomic包下面的原子变量类就是使用了乐观锁的一种实现方式CAS实现的。

-- 版本号机制
    一般是在数据表中加上一个数据版本号version字段，表示数据被修改的次数，当数据被修改时，version值会加一。当线程A要更新数据值时，在读取数据的同时也会读取version值，在提交更新时，若刚才读取到的version值为当前数据库中的version值相等时才更新，否则重试更新操作，直到更新成功。


--公平锁与非公平锁
    根据线程获取锁的抢占机制，锁可以分为公平锁和非公平锁，公平锁表示线程获取锁 的顺序是按照线程请求锁的时间早晚来决定的，也就是最早请求锁的线程将最早获取。
    而非公平锁则在运行时闯入，也就是先来不一定先得。
    --ReentrantLock有公平锁和非公平锁两种实现。


--独占锁与共享锁
    根据锁只能被单个线程持有还是能被多个线程共同持有，锁可以分为独占锁和共享锁。
    独占锁保证任何时候都只有 一个线程能得到锁， ReentrantLock 就是以独占方式实现的。
    共享锁则可以同时由多个线程持有 ，例如 ReadWriteLock 读写锁，它允许一个资源可 以被多个线程同时进行读操作 独占锁是一种悲观锁，由于每次访问资源都先加上互斥锁，这限制了并发性，因为读 操作并不会影响数据的 一致性 ，而独占锁只允许在同一 时间由一 个线程读取数据，其他线 程必须等待当前线程释放锁才能进行读取。
 共享锁则是 一种乐观锁，它放宽了加锁的条件，允许 多个线程同时进行读操作。

--可重入锁
当一个线程要获取 个被其他线程持有的独占锁时，该线程会被阻塞，那么当 一个线 程再次获取它自己己经获取的锁时是否会被阻塞呢？如果不被阻塞，那么我们说该锁是可 重入的，也就是只要该线程获取了该锁，那么可以无限次数（在高级篇中我们将知道，严 格来说是有限次数）地进入被该锁锁住的代码
实际上， synchronized内部锁是可重入锁。可重入锁的原理是在锁内部维护一个线程标示，用来标示该锁目前被哪个线程占用，然后关联一个计数器。一开始计数器值为 0, 说明该锁没有被任何线程占用。当一个钱程获取了该锁时，计数器的值会变成 1，这时其他线程再来获取该锁时会发现锁的所有者不是自己而被阻塞挂起。
 但是当获取了该锁的线程再次获取锁时发现锁拥有者是自己，就会把计数器值加＋1, 当释放锁后计数器值-1,。当计数器值为0，锁里面的线程标示被重置为 null ，这时候被阻塞的线程会被唤醒来竞争获取该锁。


--自旋锁
    由于 Java 中的线程是与操作系统中的线程 一一对应的，所以当 一个线程在获取锁（比 如独占锁）失败后，会被切换到内核状态而被挂起 当该线程获取到锁时又需要将其切换 到内核状态而唤醒该线程 而从用户状态切换到内核状态的开销是比较大的，在 一定程度 上会影响并发性能。
    自旋锁则是，当前线程在获取锁时，如果发现锁已经被其他线程占有， 它不马上阻塞自己，在不放弃 CPU 使用权的情况下，多次尝试获取（默认次数是 10），很有可能在后面几次尝试中其他线程己经释放了锁。
    如果尝试指定的次数后仍没有获取到锁则当前线程才会被阻塞挂起 由此看来自旋锁是使用 CPU 时间换取线程阻塞与调度的开销，但是很有可能这些 CPU 时间 白白浪费




--并发List

----并发包中锁

--LockSupport工具类








